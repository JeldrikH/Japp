<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Odd One Out Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 20px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(3, 150px);
      gap: 15px;
      margin: 0 auto;
      justify-content: center;
      align-items: center;
    }

    .innerGrid {
      width: 150px;
      height: 150px;
      display: grid;
      grid-template-columns: repeat(3, 50px);
      margin: 0 auto;
      justify-content: center;
      align-items: center;
    }

    .shape {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 30px;
      cursor: default;
      transition: transform 0.2s;
    }

    .pattern:hover {
      transform: scale(1.1);
    }
  </style>
</head>

<body>
  <h1>Odd One Out</h1>
  <p id="level">Level: 1</p>
  <p id="difficulty">Difficulty: 1</p>
  <p id="difficultyCounter">Difficulty Counter: 0</p>
  <div class="grid" id="grid"></div>
  <p id="message"></p>
  <p id="info"></p>

  <script>
    let level = 1;
    let difficulty = 1;
    let difficultyCounter = 0;
    let levelsPerDifficulty = 2
    let totalElements = 9;
    let patternSize = 9; // 3x3 grid

    // Define the Element struct
    function Element(shape, pattern, color) {
      this.shape = shape;
      this.pattern = pattern;
      this.color = color;
    }

    function generateLevel(level, difficulty) {
      const grid = document.getElementById('grid');
      grid.innerHTML = ''; // Clear previous patterns

      var oddOneOutIndex = Math.floor(Math.random() * totalElements);
      var elements = createElements(oddOneOutIndex, difficulty);

      for (let i = 0; i < totalElements; i++) {
        const pattern = document.createElement('div'); // Outer grid cell
        pattern.classList.add('innerGrid');

        for (let j = 0; j < patternSize; j++) {
          const symbol = document.createElement('div'); // Inner grid cell
          symbol.classList.add('shape');
          if (elements[i].pattern[j] === '1') {
            symbol.textContent = elements[i].shape; // If the bit is 1, show the shape
          }
          pattern.appendChild(symbol);
        }
        pattern.style.backgroundColor = elements[i].color;

        if (i === oddOneOutIndex) {
          pattern.onclick = () => nextLevel(true);
        } else {
          pattern.onclick = () => nextLevel(false);
        }
        grid.appendChild(pattern);
      }

    }

    function nextLevel(correct) {
      const message = document.getElementById('message');
      if (correct) {
        message.textContent = 'Correct! Moving to the next level...';
        message.innerHTML = '<span style="color: green; font-weight: bold;">&#9989; Correct! Moving to the next level...</span>';
        level++;
        difficultyCounter++;
        if (difficultyCounter >= levelsPerDifficulty) {
          difficultyCounter = 0;
          difficulty++;
        }
        if (difficulty > 6) {
          difficulty = 6; // Cap the difficulty at 6
          difficultyCounter = levelsPerDifficulty - 1; // Keep it at the last level of the current difficulty
        }

      } else {
        message.innerHTML = '<span style="color: red; font-weight: bold;">&#10060; Wrong! Next level will be generated...</span>';
        difficultyCounter--; // Decrease difficulty counter if wrong
        if (difficultyCounter < 0) {
          difficultyCounter = levelsPerDifficulty - 1; // Reset to last level of previous difficulty
          difficulty--; // Decrease difficulty if wrong#
          if (difficulty < 1) {
            difficulty = 1; // Bottom out at 1
            difficultyCounter = 0; // Keep it at 0
          }
        }
      }
      document.getElementById('level').textContent = `Level: ${level}`;
      document.getElementById('difficulty').textContent = `Difficulty: ${difficulty}`;
      document.getElementById('difficultyCounter').textContent = `Difficulty Counter: ${difficultyCounter}`;
      generateLevel(level, difficulty); // Regenerate the level
    }

    function getRandomShapes(amountOfShapes) {
      const shapes = ['▲', '●', '■', '◆', '★', '⬤', '✦', '✪', '✿'];
      const randomShapes = [];

      while (randomShapes.length < amountOfShapes) {
        const shape = shapes[Math.floor(Math.random() * shapes.length)];
        if (!randomShapes.includes(shape)) {
          randomShapes.push(shape);
        }
      }

      return randomShapes;
    }

    function getRandomPatterns(amountOfPatterns) {
      const randomPatterns = new Set();

      while (randomPatterns.size < amountOfPatterns) {
        const pattern = (Math.floor(Math.random() * (Math.pow(2, patternSize) - 1)) + 1) // Generate a random number between 1 and 511 (2^9 - 1)
          .toString(2)
          .padStart(patternSize, '0');
        randomPatterns.add(pattern);
      }

      return Array.from(randomPatterns);
    }

    function getRandomColors(amountOfColors) {
      const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'brown', 'cyan'];
      const randomColors = [];

      while (randomColors.length < amountOfColors) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        if (!randomColors.includes(color)) {
          randomColors.push(color);
        }
      }

      return randomColors;
    }

    function countSimilarities(elements, oddOneOutIndex) {
      let evenElements = elements.filter((_, index) => index !== oddOneOutIndex);
      console.log(evenElements);
      // Count the number of similarities with other elements
      let counts = [];
      let count = 0;

      for (let i = 0; i < evenElements.length; i++) {
        for (let j = 0; j < evenElements.length; j++) {
          if (i !== j) {
            ['shape', 'pattern', 'color'].forEach(property => {
              if (evenElements[i][property] === evenElements[j][property]) {
                count++;
              }
            });
          }
        }
        counts.push(count);
        count = 0; // Reset count for the next element
      }
      return counts;
    }

    function createElements(oddOneOutIndex, difficulty) {

      const elements = fillElements();
      const amountOfElementAttributes = [2, 3, 4, 5, 6, 9] //last one needs more variations
      // The first Attribue in each is the odd one out, the rest are similar
      const shapes = getRandomShapes(amountOfElementAttributes[difficulty - 1]);
      const patterns = getRandomPatterns(amountOfElementAttributes[difficulty - 1]);
      const colors = getRandomColors(amountOfElementAttributes[difficulty - 1]);

      elements[oddOneOutIndex].shape = shapes[0];
      elements[oddOneOutIndex].pattern = patterns[0];
      elements[oddOneOutIndex].color = colors[0];

      do {
        for (let i = 0; i < totalElements; i++) {
          if (i !== oddOneOutIndex) {
            elements[i].shape = shapes[Math.floor(Math.random() * (amountOfElementAttributes[difficulty - 1] - 1)) + 1];
            elements[i].pattern = patterns[Math.floor(Math.random() * (amountOfElementAttributes[difficulty - 1] - 1)) + 1];
            elements[i].color = colors[Math.floor(Math.random() * (amountOfElementAttributes[difficulty - 1] - 1)) + 1];
          }
        }
      }
      while (!validate(elements, oddOneOutIndex));

      return elements;
    }


    function validate(elements, oddOneOutIndex) {
      // Define the number of similarities per difficulty level per Element
      const similaritiesPerDifficulty = [[21, 20, 19, 18], [17, 16, 15, 14], [13, 12, 11, 10], [9, 8, 7, 6], [5, 4, 3, 2],[1]];
      // Check if the number of similarities is within the allowed range
      const count = countSimilarities(elements, oddOneOutIndex);
      document.getElementById('info').textContent = `Similarities: ${count.join(', ')}`; // Display the number of similarities
      for (let i = 0; i < count.length; i++) {
        if (!similaritiesPerDifficulty[difficulty - 1].includes(count[i])) {
          return false;
        }
      }
      return true;
    }

    function fillElements() {
      const elements = [];
      // Fill the elements array with Element objects
      for (let i = 0; i < totalElements; i++) {
        elements.push(new Element);
      }
      return elements;
    }

    // Start the game
    generateLevel(level, difficulty);
  </script>
</body>

</html>