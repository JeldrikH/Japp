<!DOCTYPE html>
<html lang="en">
<script src="../scripts/Timer.js"></script>
<script src="../scripts/GameDataManager.js"></script>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Odd One Out Game</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 20px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(3, 150px);
      gap: 15px;
      margin: 0 auto;
      justify-content: center;
      align-items: center;
    }

    .innerGrid {
      width: 150px;
      height: 150px;
      display: grid;
      grid-template-columns: repeat(3, 50px);
      margin: 0 auto;
      justify-content: center;
      align-items: center;
    }

    .shape {
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 30px;
      cursor: default;
      transition: transform 0.2s;
    }

    .pattern:hover {
      transform: scale(1.1);
    }
  </style>
</head>

<body>
  <h1>Odd One Out</h1>
  <p id="level">Level: 1</p>
  <p id="difficulty">Difficulty: 1</p>
  <p id="difficultyCounter">Difficulty Counter: 0</p>
  <div class="grid" id="grid"></div>
  <p id="message"></p>
  <button id="skipButton" onclick="nextLevel(-9)">Skip</button>
  <script>
    let level = 1;
    let difficulty = 1;
    let difficultyCounter = 0;
    let levelsPerDifficulty = 2
    let totalElements = 9;
    let patternSize = 9; // 3x3 grid
    const timer = new Timer();
    const gameDataManager = new GameDataManager()
    gameDataManager.setGameType('odd-one-out'); // Set the game type for GameDataManager
    // Define the Element struct
    function Element(shape, pattern, color) {
      this.shape = shape;
      this.pattern = pattern;
      this.color = color;
    }

    function generateLevel(level, difficulty) {
      timer.startTimer();
      const grid = document.getElementById('grid');
      grid.innerHTML = ''; // Clear previous patterns

      var oddOneOutIndex = Math.floor(Math.random() * totalElements);
      var elements = createElements(oddOneOutIndex, difficulty);

      for (let i = 0; i < totalElements; i++) {
        const pattern = document.createElement('div'); // Outer grid cell
        pattern.classList.add('innerGrid');

        for (let j = 0; j < patternSize; j++) {
          const symbol = document.createElement('div'); // Inner grid cell
          symbol.classList.add('shape');
          if (elements[i].pattern[j] === '1') {
            symbol.textContent = elements[i].shape; // If the bit is 1, show the shape
          }
          pattern.appendChild(symbol);
        }
        pattern.style.backgroundColor = elements[i].color;

        if (i === oddOneOutIndex) {
          pattern.onclick = () => nextLevel(1);
        } else {
          pattern.onclick = () => nextLevel(0);
        }
        grid.appendChild(pattern);
      }

    }

    function nextLevel(correct) {
      timer.stopTimer(); // Stop the timer when the user clicks
      const time = timer.getElapsedTimeInSeconds(); // Get the elapsed time
      gameDataManager.addGameData(difficulty, time, correct); // Save game data
      console.log(gameDataManager.getData()); // Log the game data for debugging
      const message = document.getElementById('message');
      if (correct === 1) {
        message.textContent = 'Correct! Moving to the next level...';
        message.innerHTML = '<span style="color: green; font-weight: bold;">&#9989; Correct! Moving to the next level...</span>';
        level++;
        difficultyCounter++;
        if (difficultyCounter >= levelsPerDifficulty) {
          difficultyCounter = 0;
          difficulty++;
        }
        if (difficulty > 6) {
          difficulty = 6; // Cap the difficulty at 6
          difficultyCounter = levelsPerDifficulty - 1; // Keep it at the last level of the current difficulty
        }

      } else if (correct === 0) {
        message.innerHTML = '<span style="color: red; font-weight: bold;">&#10060; Wrong! Next level will be generated...</span>';
        difficultyCounter--; // Decrease difficulty counter if wrong
        if (difficultyCounter < 0) {
          difficultyCounter = levelsPerDifficulty - 1; // Reset to last level of previous difficulty
          difficulty--; // Decrease difficulty if wrong#
          if (difficulty < 1) {
            difficulty = 1; // Bottom out at 1
            difficultyCounter = 0; // Keep it at 0
          }
        }
      } else if (correct === -9) {
        message.innerHTML = '<span style="color: orange; font-weight: bold;">&#10067; Skipped! Next level will be generated...</span>';
      }
      document.getElementById('level').textContent = `Level: ${level}`;
      document.getElementById('difficulty').textContent = `Difficulty: ${difficulty}`;
      document.getElementById('difficultyCounter').textContent = `Difficulty Counter: ${difficultyCounter}`;
      generateLevel(level, difficulty); // Regenerate the level
    }

    function getRandomShapes(amountOfShapes) {
      const shapes = ['▲', '●', '■', '◆', '★', '⬤', '✦', '✪', '✿'];
      const randomShapes = [];

      while (randomShapes.length < amountOfShapes) {
        const shape = shapes[Math.floor(Math.random() * shapes.length)];
        if (!randomShapes.includes(shape)) {
          randomShapes.push(shape);
        }
      }

      return randomShapes;
    }

    function getRandomPatterns(amountOfPatterns) {
      const randomPatterns = new Set();

      while (randomPatterns.size < amountOfPatterns) {
        const pattern = (Math.floor(Math.random() * (Math.pow(2, patternSize) - 1)) + 1) // Generate a random number between 1 and 511 (2^9 - 1)
          .toString(2)
          .padStart(patternSize, '0');
        randomPatterns.add(pattern);
      }

      return Array.from(randomPatterns);
    }

    function getRandomColors(amountOfColors) {
      const colors = ['red', 'blue', 'green', 'yellow', 'purple', 'orange', 'pink', 'brown', 'cyan'];
      const randomColors = [];

      while (randomColors.length < amountOfColors) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        if (!randomColors.includes(color)) {
          randomColors.push(color);
        }
      }

      return randomColors;
    }

    function countSimilarities(elements, oddOneOutIndex) {
      let evenElements = elements.filter((_, index) => index !== oddOneOutIndex);
      // Count the number of similarities with other elements
      let counts = [];
      let count = 0;

      for (let i = 0; i < evenElements.length; i++) {
        for (let j = 0; j < evenElements.length; j++) {
          if (i !== j) {
            ['shape', 'pattern', 'color'].forEach(property => {
              if (evenElements[i][property] === evenElements[j][property]) {
                count++;
              }
            });
          }
        }
        counts.push(count);
        count = 0; // Reset count for the next element
      }
      return counts;
    }

    function createElements(oddOneOutIndex, difficulty) {
      var elements = fillElements();
      const amountOfElementAttributes = [3, 4, 5, 6, 7, 8]; // Number of attributes per difficulty
      const similaritiesPerDifficulty = [18, 14, 10, 6, 2, 1]; // Reference similarities per difficulty (not a fixed value)

      // Get the number of attributes and similarities for the current difficulty
      const numAttributes = amountOfElementAttributes[difficulty - 1];
      const targetSimilarities = similaritiesPerDifficulty[difficulty - 1]; // Use the highest similarity for now

      // Generate random attributes
      const shapes = getRandomShapes(numAttributes);
      const patterns = getRandomPatterns(numAttributes);
      const colors = getRandomColors(numAttributes);

      // Define the odd one out
      elements[oddOneOutIndex].shape = shapes[0];
      elements[oddOneOutIndex].pattern = patterns[0];
      elements[oddOneOutIndex].color = colors[0];


      // Fill the other elements
      for (let i = 0; i < totalElements; i++) {
        if (i === oddOneOutIndex) continue;

        // Define undefined attibutes for the current iteration
        if (typeof elements[i].shape === 'undefined') {
          elements[i].shape = shapes[Math.floor(Math.random() * (numAttributes - 1)) + 1];
        }
        if (typeof elements[i].pattern === 'undefined') {
          elements[i].pattern = patterns[Math.floor(Math.random() * (numAttributes - 1)) + 1];
        }
        if (typeof elements[i].color === 'undefined') {
          elements[i].color = colors[Math.floor(Math.random() * (numAttributes - 1)) + 1];
        }

        // Determine how many attributes should match
        let remainingSimilarities = targetSimilarities - countSimilarities(elements, oddOneOutIndex)[i];

        // Assign attributes to ensure the desired number of similarities
        while (remainingSimilarities > 0) {

          // Force quit the loop if all attributes are defined
          for (let i = 0; i < elements.length; i++) {
            if (elements[i].shape === undefined) {
              break
            }
            if (elements[i].pattern === undefined) {
              break
            }
            if (elements[i].color === undefined) {
              break
            }
            if (i === elements.length - 1) {
              if (!validate(elements, oddOneOutIndex)) {
                elements = createElements(oddOneOutIndex, difficulty); // Recursively call to ensure the result is valid
              }
              return elements; // All attributes are defined, exit the loop
            }
          }
          const chosenAttribute = Math.floor(Math.random() * 3); // Randomly choose the attribute to match
          const chosenElement = Math.floor(Math.random() * 9); // Randomly choose the element to match

          if (chosenElement === oddOneOutIndex || chosenElement === i) {
            continue; // Ensure we don't match the odd one out or the current element
          }

          switch (chosenAttribute) {
            case 0:
              if (typeof elements[chosenElement].shape === 'undefined') {
                elements[chosenElement].shape = elements[i].shape;
                remainingSimilarities--;
                break;
              }

            case 1:
              if (typeof elements[chosenElement].pattern === 'undefined') {
                elements[chosenElement].pattern = elements[i].pattern;
                remainingSimilarities--;
                break;
              }

            case 2:
              if (typeof elements[chosenElement].color === 'undefined') {
                elements[chosenElement].color = elements[i].color;
                remainingSimilarities--;
                break;
              }
          }
        }
      }
      if (!validate(elements, oddOneOutIndex)) {
        elements = createElements(oddOneOutIndex, difficulty); // Recursively call to ensure the result is valid
      }
      return elements;
    }


    function validate(elements, oddOneOutIndex) {
      const count = countSimilarities(elements, oddOneOutIndex);
      // Check if there is an element without similarities
      for (let i = 0; i < count.length; i++) {
        if (count[i] === 0) {
          return false;
        }
      }
      return true;
    }

    function fillElements() {
      const elements = [];
      // Fill the elements array with Element objects
      for (let i = 0; i < totalElements; i++) {
        elements.push(new Element);
      }
      return elements;
    }

    // Start the game
    generateLevel(level, difficulty);
  </script>
</body>

</html>